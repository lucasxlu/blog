---
title: "[Algorithm] Sort"
date: 2018-08-02 11:37:29
mathjax: true
tags:
- Algorithm
- Data Structure
- Graph
catagories:
- Algorithm
- Data Structure
- Graph
---
## 初级排序算法
### 选择排序
首先找到数组中最小的那个元素，其次，将它和数组中的第一个元素交换位置（如果第一个元素就是最小元素就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组中第二个元素交换位置。如此往复，直至将整个数组排序。这叫做 __选择排序__，因为它总是在不断选择剩余元素中最小的元素。

> 对于长度为$N$的数组，选择排序需要大约$N^2/2$次比较与$N$次交换。

```java
public int[] selectSort (int[] input) {
    for (int i = 0; i < input.length; i++) {
        int min = i;
        for (int j = i + 1; j < input.length; j++) {
            if (input[j] < input[min]) {
                min = j;
            }
        }
        if (input[min] != input[i]) {
            int tmp = input[min];
            input[min] = input[i];
            input[i] = tmp;
        }
    }

    return input;
}
```
* 选择排序的运行时间和输入无关，为了找到最小元素而扫描一遍数组并不能为下一遍扫描提供什么信息。
* 选择排序的数据移动是最少的，每次交换都会改变两个数组元素的值，因此选择排序用了$N$次交换——交换次数和数组大小是线性关系。

### 插入排序
为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的位置腾出空间，它们可能会被移动。但是当索引到达数组最右端，数组排序就完成了。__与选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序__。

> 对于随机排列的长度为$N$且主键不重复的数组，平均情况下插入排序需要$\sim N^2/4$次比较以及$\sim N^2/4$次交换。最坏情况下需要$\sim N^2/2$比较和$\sim N^2/2$次交换。最好情况下需要$N-1$次比较和0次交换。

```java
public int[] insertSort(int[] input) {
    for (int i = 0; i < input.length; i++) {
        for (int j = i; j > 0 && input[j] < input[j - 1]; j--) {
            int tmp = input[j];
            input[j] = input[j - 1];
            input[j - 1] = tmp;
        }
    }

    return input;
}
```
> 插入排序对部分有序的数组十分高效，也很适合小规模数组。

> 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是$O(N^2)$级别的。

### 希尔排序
希尔排序是一种基于插入排序的快速排序算法，对于大规模乱序数组，插入排序很慢，因为它只会交换相邻元素，因此元素只能一点点从数组一端移动到另一端。因此，希尔排序为了加速简单地改进了插入排序，__交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序__。

希尔排序的思想是使数组中任意间隔为$h$的元素都是有序的，这样的数组被称为$h$有序数组。对于每一个$h$，用插入排序将$h$个子数组独立地排序，但因为子数组是相互独立的，一个更简单的方法是在$h-$子数组中将每个元素交换到比它大的元素之前去。只需要在插入排序的代码中将移动元素的距离由1改为$h$即可。这样，希尔排序的实现就转换为一个类似于插入排序但使用不同增量的过程。

希尔排序更高效的原因是它权衡了子数组的规模和有序性，排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。

```java
public int[] shellSort(int[] input) {
    int h = 1;
    while (h < input.length / 3)
        h = 3 * h + 1;

    while (h >= 1) {
        for (int i = h; i < input.length; i++) {
            for (int j = i; j >= h && input[j] < input[j - h]; j -= h) {
                int tmp = input[j];
                input[j] = input[j - h];
                input[j - h] = tmp;
            }

            h /= 3;
        }
    }

    return input;
}
```

> 最坏情况下，希尔排序的比较次数和$N^{3/2}$成正比。

### 归并排序
要将一个数组排序，可以先递归地将它分成两半分别排序，然后将结果归并起来。归并排序能够保证任意长度为$N$的数组排序所需的时间$NlogN$成正比；它的主要缺点是它所需要的额外空间和$N$成正比。

* 原地归并
```java

```